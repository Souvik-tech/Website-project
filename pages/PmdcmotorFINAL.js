/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import React, { useRef,Suspense,useState } from 'react'
import { useGLTF, useAnimations,OrbitControls,Environment } from '@react-three/drei'
import { Canvas ,useFrame} from '@react-three/fiber'

import { EffectComposer, SelectiveBloom,SSAO ,Bloom,Vignette} from '@react-three/postprocessing'
import {proxy,useSnapshot} from 'valtio'
import {useControls,folder} from 'leva'

import { BlurPass, Resizer, KernelSize  ,BlendFunction} from 'postprocessing'


const state =proxy({
  current:null,
  
  run:Clockwise,
  items:{
    Commutator:'#b87333',
    ARMATURE:'#ffffff'
  }
} );
function Clockwise({ clock }) {
  const a = clock.getElapsedTime();
  // mta.current.rotation.x = a;
};

 function Model(props) {
  const group = useRef()
  const snap =useSnapshot(state)
  const mta=useRef()
  const meshRef1=useRef()
  const meshRef2=useRef()
  

  const { nodes, materials, animations } = useGLTF('models/pmdcmotorFINAL.gltf')
  const { actions } = useAnimations(animations, group)
  const[hover,set]=useState(null)

 
 


  
  return (
    <>
    <group ref={group}  dispose={null}
    onPointerOver={(e)=>{e.stopPropagation(),set(e.object.material.name)}}
    onPointerOut={(e)=>{e.intersections.length===0 && set(null)}}
    onClick={(e)=>{e.stopPropagation(),state.current=e.object.material.name}}
    onPointerMissed={(e)=>{state.current=null}}>
      <mesh
        name="Commutator"
       
        material-color={snap.items.Commutator}
        castShadow
        receiveShadow
        geometry={nodes.Commutator.geometry}
        material={materials['Material.001']}
        position={[23.26, 0.08, -0.14]}
        rotation={[-1.11, 0, 0]}
        scale={[0.87, 0.87, 0.87]}>

        <mesh
          ref={props.selection}
          name="ARMATURE"
          material-color={snap.items.ARMATURE}
          castShadow
          receiveShadow
          geometry={nodes.ARMATURE.geometry}
          material={materials['Material.028']}
          position={[0, 0, 0]}
          rotation={[2.32, 0, -Math.PI / 2]}
          scale={[6.55, 6.55, 6.55]}
          
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.Armaturewire.geometry}
          material={nodes.Armaturewire.material}
          position={[0, 0, 0]}
          rotation={[-0.61, 0, 0]}
          scale={[1.15, 1.15, 1.15]}
        />
        <mesh
          castShadow
          receiveShadow
          geometry={nodes.CommutatorSupport.geometry}
          material={materials['commutator support']}
          position={[-20.09, 0, 0]}
          rotation={[-0.22, 0, -Math.PI / 2]}
          scale={[4.11, 4.11, 4.11]}
        />
      </mesh>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Battery.geometry}
        material={materials['Material.003']}
        position={[-2.33, 0.08, -0.31]}
        rotation={[Math.PI / 2, 0, 0]}
        scale={[0.7, 0.7, 0.7]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.WireFromBattery.geometry}
        material={nodes.WireFromBattery.material}
        position={[-2.33, 0.08, -0.32]}
       
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Statorcore.geometry}
        material={materials['Material.004']}
        position={[15.84, 0.08, -0.14]}
        rotation={[0, 0, -Math.PI / 2]}
        scale={[16.51, 16.51, 16.51]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Southpole.geometry}
        material={materials['Material.006']}
        position={[23.26, 0.08, -11.71]}
        scale={[5.4, 9.5, 5.4]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Northpole.geometry}
        material={materials['Material.005']}
        position={[23.26, 0.08, 11.31]}
        rotation={[-Math.PI, 0, 0]}
        scale={[5.4, 9.5, 5.4]}
      />
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube.geometry}
        material={materials['Material.002']}
        position={[6.16, 0.08, -0.14]}
        scale={[0.59, 0.59, 0.59]}
        
      />
    </group>
    
    </>
  )
}
function Pick(){
  const snap =useSnapshot(state)
  return(
    <div>{snap.current}</div>
  )
}


useGLTF.preload('/pmdcmotorFINAL.gltf')
/*
Auto-generated by: https://github.com/pmndrs/gltfjsx
*/

import  { useEffect ,} from 'react'


 function Box({action,props}) {
  const group = useRef()
  const { nodes, materials, animations } = useGLTF('models/box.glb')
  const { actions } = useAnimations(animations, group)
  const box = useRef()
  
 
  return (
    <group ref={group}  dispose={null}>
      <mesh
        castShadow
        receiveShadow
        geometry={nodes.Cube.geometry}
        material={materials.Material}
        position={[-20,0,0]}
        ref={box}
      />
    </group>
  )
}

useGLTF.preload('/box.glb')

export default function New(){
 
  const { myNumber } = useControls({
    myNumber: {
      value: 4,
      min: 0,
      max: 1,
      step: 0.001,
    },
  })
  
  return(
    <>
    <div className='w-screen h-screen'>
    
      <Pick/>
     
      <Canvas>
      <color attach="background" args={["#050505"]} />
     <OrbitControls/>

     <Suspense fallback={null}>
        <Model scale={0.6} position={0,0,0} />
        <Box   />
       
        <ambientLight  />
        <directionalLight  />
        <pointLight position={[-10,0,0]} intensity={myNumber}/>

       
      </Suspense>
       

      </Canvas>
      
      
      </div>
    </>
  )
}


